# maxcut-GA
23년 1학기 알고리즘 프로젝트: 하이브리드 유전 알고리즘 구현

## ToC
- [maxcut-GA](#maxcut-ga)
  - [ToC](#toc)
- [문제](#문제)
- [basic GA 설계](#basic-ga-설계)
  - [basic GA 구조](#basic-ga-구조)
  - [basic GA 구조 요약](#basic-ga-구조-요약)
  - [basic GA 해의 표현](#basic-ga-해의-표현)
  - [basic GA 연산자](#basic-ga-연산자)
- [island GA 설계](#island-ga-설계)
  - [island GA 구조](#island-ga-구조)
  - [island GA 구조, 해의 표현](#island-ga-구조-해의-표현)
  - [Dynamic programming을 활용한 방안](#dynamic-programming을-활용한-방안)
  - [island GA 연산자](#island-ga-연산자)

# 문제
주어진 그래프를 두 부류로 나누고, 각 부류를 연결하는 간선의 합이 최대가 되게 하라.

# basic GA 설계
1. 사용한 GA 구조(팀원 별 의견 표를 포함할 것)
2. 해의 표현(chromosome design, 팀원 별 의견 표를 포함할 것)
3. 사용한 연산자에 대한 설명(selection, crossover, mutation, replacement 등, 팀원 별 의견 표를 포함할 것)

GA의 과정

```md
1. 랜덤한 해를 생성하고(`P_0`) 각 해의 cost 계산
2. 랜덤한 두 부모를 선택 후 교배(원하는 방식대로 섞기)
    * 낮은 확률로 돌연변이 발생(랜덤하게 뭔가 바뀜)
3. 생성된 자식은 전체 유전자 풀에서 안 좋은 해를 대체함
4. 위의 과정을 반복
5. 특정한 조건 하에 반복을 중단하고 가장 좋은 해를 반환함
```

## basic GA 구조
1. 랜덤 해 생성 및 cost 계산
    1. 노드의 수만큼 A와 B를 각각 50% 확률로 뽑음. A가 뽑힐 확률과 B가 뽑힐 확률이 동일하며, 각 노드마다 뽑히는 사건은 독립적이고, 순서가 유의미하여 모든 해가 서로 다른 해로 간주되기 때문에 모든 해가 균등하게 생성될 확률을 갖는다.
    2. 해가 유효한지 확인  
        * 두 부류는 모두 최소 1개 이상의 노드를 가져야 한다.
        * 두 부류는 최소 1개 이상의 간선으로 서로 연결되어야 한다: 한쪽 부류에 있는 노드가 갖는 모든 간선 중 반대쪽 부류로 이어지는 게 하나라도 있으면 통과
    3. 한 쪽 부류의 모든 노드가 갖는 모든 간선을 검사해 cost 계산: 예를 들어 A 부류에 속한 노드가 갖는 모든 간선 중 B 부류에 속한 노드로 연결되는 간선의 가중치의 합을 계산. 반대로 계산해도 답은 같다(그렇지 않다면 해가 잘못 생성된 것임).
2. 랜덤 부모 선택 후 교배
    1. 부모 선택: 다음 과정을 2번 반복하여 뽑는다.
        1. 중복 여부를 따지지 않고 2^3 ~ 2^5개 사이로(2의 거듭제곱수로) cost를 뽑는다. 이때 뽑히는 cost는 무조건 해당하는 해가 있는 것만 뽑는다.
        2. 뽑힌 cost끼리 토너먼트를 하여 마지막 하나의 cost를 정한다.
        3. 해당 cost에 해당하는 해 중 하나를 랜덤으로 뽑는다.
    2. 교배: 유전자의 각 자리마다 50% 확률로 부모 둘 중 한 쪽의 것을 선택함. 한 번에 하나의 자식만 생성한다.
    3. 돌연변이: 자식 유전자의 각 자리마다 일정 확률로 다시 선택함. 바꾸는 것이 아니라 다시 선택하는 것이므로 바뀌기 전과 똑같을 수 있다. 정확한 확률은 전체 그래프의 노드 수에 비례하며, 평균적으로 0.8% 내외가 되도록 조정했다.
    4. 자식 유효성 검사: 유효하지 않은 해가 생성되었다면 즉시 제거하며 다시 생성하지 않는다.
3. 세대별 대체
    1. 한 세대에서 자식의 수는 전체 풀의 10%가 되도록 한다.
    2. 생성된 자식들은 자신과 cost가 조금 작은 유전자를 대체한다. 만약 대체할 유전자가 없다면 자식이 삭제된다.
        * 만약 한 세대에서 생성된 자식 중 50% 이상이 대체할 수 있는 유전자가 없었다면 진화가 수렴한 것으로 판단하고 진화를 종료한다.
4. 다시 진화가 수렴하거나, 제한시간이 다 되면 cost가 제일 큰 해를 반환한다.

## basic GA 구조 요약
1. 노드의 수만큼 A와 B를 50% 확률로 뽑아 해를 생성하고, 유효한 해인지 검사하면서 cost를 계산하여 부모 집합을 만든다.
2. cost 토너먼트를 2번 진행해 두 부모를 뽑는다. 자식은 해의 각 자리마다 50% 확률로 부모의 유전자 중 하나를 선택한다. 자식은 하나 생성하며, 유효성을 검사해 무효한 것은 바로 제거하고 다시 생성하지 않는다. 돌연변이는 해의 각 자리마다 일정 확률로 값을 재선택함으로써 발생한다.
3. 초기 풀의 유전자 수의 일정 비율만큼 교배를 반복하여 생성된 자식들은 자신보다 cost가 조금 작은 유전자를 대체한다. 대체할 유전자가 없는 경우 제거된다.
4. 한 세대에서 일정 비율 이상의 자식이 대체하지 못하고 제거되거나 제한 시간이 다 되었을 때 보유한 최선의 해를 반환한다.

## basic GA 해의 표현
A와 B 두 가지 기호를 그래프에 존재하는 노드 수만큼 나열하여 문자열 형태로 해를 표현한다. 인덱스는 1부터 시작하는 것으로 취급하며 문자열의 인덱스와 노드의 번호가 같고, 해당 자리의 글자가 해당 노드가 속한 그룹을 의미한다. cost는 두 그룹의 노드를 잇는 가중치의 총합으로 정한다.

## basic GA 연산자
* validation: 모든 해가 생성될 때 그것이 유효한지 검사한다. 두 그룹에 최소 하나 이상의 노드가 포함되고, 두 그룹을 잇는 간선이 최소 하나 이상 존재하는 것을 유효함으로 정의한다.
* selection: cost를 기준으로 토너먼트를 하고, 뽑힌 cost를 갖는 해 중에서 랜덤하게 뽑는다.
* crossover: 해의 각 자리마다 50% 확률로 두 부모의 유전자 중 하나를 선택한다.
* mutation: 해의 각 자리마다 일정 확률로 값을 다시 선택하며, 이전의 값과 똑같을 수 있다. 해의 길이에 비례하여 평균 약 0.8%의 확률로 발생한다.
* replacement: generational GA 방식 이용, 자신보다 cost가 약간 작은 것과 대체한다.

# island GA 설계
1. 사용한 GA 전체 구조, 해의 표현
2. Dynamic programming을 활용한 방안
3. 사용한 GA 연산자(selection, crossover, mutation, replacement 등)에 대한 설명과 DP 알고리즘 설명

GA의 과정

```md
1. 랜덤한 해를 생성하고(`P_0`) 각 해의 cost 계산
2. 랜덤한 두 부모를 선택 후 교배(원하는 방식대로 섞기)
    * 낮은 확률로 돌연변이 발생(랜덤하게 뭔가 바뀜)
3. 생성된 자식은 전체 유전자 풀에서 안 좋은 해를 대체함
4. 위의 과정을 반복
5. 특정한 조건 하에 반복을 중단하고 가장 좋은 해를 반환함
```

## island GA 구조
1. 랜덤 해 생성 및 cost 계산
    1. 노드의 수만큼 A와 B를 각각 50% 확률로 뽑음. A가 뽑힐 확률과 B가 뽑힐 확률이 동일하며, 각 노드마다 뽑히는 사건은 독립적이고, 순서가 유의미하여 모든 해가 서로 다른 해로 간주되기 때문에 모든 해가 균등하게 생성될 확률을 갖는다.
    2. 해가 유효한지 확인  
        * 두 부류는 모두 최소 1개 이상의 노드를 가져야 한다.
        * 두 부류는 최소 1개 이상의 간선으로 서로 연결되어야 한다: 한쪽 부류에 있는 노드가 갖는 모든 간선 중 반대쪽 부류로 이어지는 게 하나라도 있으면 통과
    3. 한 쪽 부류의 모든 노드가 갖는 모든 간선을 검사해 cost 계산: 예를 들어 A 부류에 속한 노드가 갖는 모든 간선 중 B 부류에 속한 노드로 연결되는 간선의 가중치의 합을 계산. 반대로 계산해도 답은 같다(그렇지 않다면 해가 잘못 생성된 것이며, 이는 별도로 확인하지 않는다).
    4. 생성된 해는 생성된 순서에 따라 교대로 두 대륙 풀에 투입된다.
2. 랜덤 부모 선택 후 교배
    1. 부모 선택: 한 대륙에서 두 부모를 뽑는다. cost 토너먼트 방식으로 female이 먼저 뽑히고, 뽑힌 female의 cost에 따라 male이 선택된다. male은 토너먼트를 하지 않는다. thresh를 설정해 서로 cost가 일정량 이하로 차이나는 부모하고만 교배할 수 있게 한다(대상 male이 없을 경우 자신과 cost가 같은 해 중에서 뽑는다). 또한 낮은 확률로 세기의 사랑 발생, cost 차이가 thresh 값을 넘어서는 부모 쌍이 드물게 생성된다. 기본적으로 부모 한 쌍은 하나의 자식을 생성하지만 이 경우 자식을 둘 생성한다.
    2. 교배: 유전자의 각 자리마다 60% 확률로 cost가 더 높은 부모의 유전자 선택, 생성된 자식은 돌연변이 후 반환.
    3. 돌연변이: 유전자의 길이에 비례하여 발생 횟수를 정하고, 자식 유전자의 랜덤 자리에서 일정 확률로 재선택함. 바꾸는 것이 아니라 다시 선택하는 것이므로 바뀌기 전과 똑같을 수 있다. 해의 길이에 비례하여 평균 약 0.8% 확률로 발생하게 한다.
    4. 자식 유효성 검사: 유효하지 않은 해가 생성되었다면 즉시 제거하며 다시 생성하지 않는다.
3. 세대별 대체
    1. 한 세대에서 부모 선택 횟수는 초기 풀 크기의 40%가 되도록 한다.
    2. 생성된 자식들은 자신보다 cost가 조금 작은 유전자를 대체한다. 만약 대체할 유전자가 없다면 98% 확률로 제거되거나 2% 확률로 아무도 대체하지 않고 풀에 추가된다.
        * 만약 한 세대에서 생성된 자식 중 30% 이상이 대체할 수 있는 유전자가 없었다면 진화가 수렴한 것으로 판단하고 지역 최적화를 잠깐 한 후 대륙 통합 교배를 시작, 위의 과정을 반복하고 재차 수렴했을 때 종료한다.
4. 지역 최적화: 지정된 대륙에서 최고 cost를 갖는 해 하나만을 가져와 제한된 시간 동안 지역 최적화를 한다. 해를 바꿔도 cost가 그대로인 경우가 일정 횟수만큼 누적되면 종료한다.
5. 진화 및 지역 최적화가 끝나거나, 제한시간이 다 되면 cost가 제일 큰 해를 반환한다.

## island GA 구조, 해의 표현
1. 해는 노드 길이만큼의 'A'와 'B'로 구성된 문자열이다. 노드의 수만큼 A, B를 50% 확률로 뽑아 해를 생성하고, 유효한 해인지 검사하며 cost를 계산하고 대륙을 부여해 부모 집합을 만든다.
2. 서로 같은 대륙끼리 교배한다. female이 cost 토너먼트로 먼저 뽑히고, female의 cost에 따라 male이 선택된다. 부모의 cost 차이가 서로 일정량 이하인 경우만 교배하도록 하며, 낮은 확률로 cost 차이가 큰 부모 쌍이 생성될 수 있고, 자식도 더 많이 생성한다. 자식은 생성 직후 돌연변이를 시도하며, 생성된 자식을 검사해 유효하지 않은 것은 바로 제거한다.
3. 초기 풀의 유전자 수의 40%만큼 부모 쌍을 선택하여 생성된 자식들은 자신보다 cost가 약간 작은 유전자를 대체한다. 대체할 유전자가 없는 경우 높은 확률로 제거된다.
4. 제한 시간 내에 대륙 내 진화가 수렴하면 지역 최적화를 잠깐 시도한 후 대륙 통합 진화를 시작한다.
5. 진화 및 지역 최적화가 끝나거나 제한 시간이 다 되었을 때 최선의 해를 반환한다.

## Dynamic programming을 활용한 방안
* 지역 최적화를 할 때는 비슷한 해의 cost를 자주 계산하게 된다. 지역 최적화 내에서의 cost 계산에 대해 memo map을 추가해 중복된 cost 계산을 줄였다. 이후 모든 해의 validation 과정에 memo를 사용해 전체적인 cost 계산 시간을 줄였다.
* 지역 최적화를 할 때 해를 한 자리 변경해도 cost가 유지되는 경우가 있다. 이때 바뀐 해를 이용해 최적화를 계속하는 게 더 나은지, 이전 해를 이용하는 게 더 나은지 두 가지 경우에 대해 모두 지역 최적화 함수를 다시 호출하고 결과가 더 좋은 해를 사용한다. 다만 재귀호출된 지역 최적화 함수 내에서도 다시 재귀호출을 하면 스택 오버플로우가 발생하여 재귀 호출은 한 번으로 제한된다. 이 방법을 사용하면 성능이 하락하여 지금은 폐기하였다.

## island GA 연산자
사용한 GA 연산자(selection, crossover, mutation, replacement 등)에 대한 설명과 DP 알고리즘 설명

* validate: 해의 유효성을 검사함과 동시에 해의 cost를 계산한다. 계산한 모든 해의 cost는 map으로 저장하여 이후 재사용한다.
* selection: 전체 유전자 풀을 두 대륙으로 나누어, 서로 같은 대륙끼리 교배한다. 부모의 cost 차이를 일정 수치로 제한하나 낮은 확률로 제한되지 않은 쌍이 생성될 수 있다.
* crossover: 해의 각 자리를 60% 확률로 부모 중 우월한 쪽의 것으로 선택한다.
* mutation: 각 자리마다 일정 확률로 다시 선택하며, 이전의 값과 똑같을 수 있다. 평균 약 0.8% 발생.
* replacement: generational GA 방식 이용, cost가 약간 작은 것과 대체한다. 대체 실패한 해는 낮은 확률로 그대로 pool에 포함된다.
* local optimization: 현재 보유한 해 중 가장 좋은 것을 선택, 해의 각 자리를 랜덤한 순서로 flip하여 cost가 같거나 커지는 쪽으로 해를 바꾼다. 일정 횟수 이상 개선되지 않을 때까지 한다. validation 시간을 줄이기 위해 계산한 모든 해의 cost는 map에 저장되고 재사용된다.